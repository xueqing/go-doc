# 常见问题解答

- [常见问题解答](#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e8%a7%a3%e7%ad%94)
  - [起源](#%e8%b5%b7%e6%ba%90)
  - [用法](#%e7%94%a8%e6%b3%95)
  - [设计](#%e8%ae%be%e8%ae%a1)
    - [为什么 Go 没有断言](#%e4%b8%ba%e4%bb%80%e4%b9%88-go-%e6%b2%a1%e6%9c%89%e6%96%ad%e8%a8%80)
  - [类型](#%e7%b1%bb%e5%9e%8b)
  - [值](#%e5%80%bc)
  - [编写代码](#%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81)
  - [指针和分配](#%e6%8c%87%e9%92%88%e5%92%8c%e5%88%86%e9%85%8d)
  - [并发](#%e5%b9%b6%e5%8f%91)
  - [函数和方法](#%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%b9%e6%b3%95)
  - [控制流](#%e6%8e%a7%e5%88%b6%e6%b5%81)
  - [包和测试](#%e5%8c%85%e5%92%8c%e6%b5%8b%e8%af%95)
  - [实现](#%e5%ae%9e%e7%8e%b0)
    - [我最喜欢的测试辅助函数在哪里](#%e6%88%91%e6%9c%80%e5%96%9c%e6%ac%a2%e7%9a%84%e6%b5%8b%e8%af%95%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0%e5%9c%a8%e5%93%aa%e9%87%8c)
  - [性能](#%e6%80%a7%e8%83%bd)
  - [从 C 的改变](#%e4%bb%8e-c-%e7%9a%84%e6%94%b9%e5%8f%98)

参考 [Go 官方文档——常见问题解答](https://golang.org/doc/faq#assertions)学习。

## 起源

## 用法

## 设计

### 为什么 Go 没有断言

Go 不提供断言。他们无疑是方便的，但是我们已有的经验是开发人员依赖断言避免思考合适的错误处理和报告。合适的错误处理意味着服务在一个非严重的错误之后继续操作而不是崩溃。合适的错误处理意味着错误是直接的、扼要的，使开发人员免于解释大量的崩溃跟踪。当看到错误的开发人员不熟悉代码，错误的准确尤为重要。

我们明白这是一个争论点。Go 语言和库有很多不同于现代实践的地方，只是因为我们感觉有时候值得尝试一个不同的方法。

## 类型

## 值

## 编写代码

## 指针和分配

## 并发

## 函数和方法

## 控制流

## 包和测试

## 实现

### 我最喜欢的测试辅助函数在哪里

Go 的标准 [testing](../golangpkg/testing.md) 包使得易于编写单元测试，但是它缺少其他语言测试框架提供的一些特性，比如断言函数。此文档[前面的部分](#为什么-Go-没有断言)解释了为什么 Go 没有断言，以及在测试中使用断言的相同论点。合适的错误处理意味着使得其他测试在一个测试失败时继续运行，以便调试错误的人员可以得到一个错误的完整信息。对于一个测试来说，比起报告 isPrime 对于 2 的答案是错误的并因此不再运行更多测试，报告 isPrime 对 2、3、5、7 (或 2、4、8、16) 给出错误的答案是更加有用的。触发测试错误的开发人员可能不熟悉失败的代码。在测试失败时，花费时间编写一个好的错误消息是值得的。

相关的一点是测试框架趋向于发展成为他们自己的微语言，包括条件、控制和打印机制，但是 Go 已经有所有这些功能了；为什么要创建他们？我们更愿意用 Go 编写测试；它是一门学习更少的语言，而且这个方法保持测试是直截了当易于理解的。

如果编写好的错误所需的额外代码数量看起来是重复的、巨大的，那么表驱动测试可能效果更好。表驱动是迭代遍历定义在一个数据结构(Go 对于数据结构字面量有极好的支持)的输入和输出列表。编写一个好的测试和错误信息的工作在测试拥挤很多时将会被分摊。标准的 Go 库有许多说明示例，比如 [fmt 包的格式化测试](https://golang.org/src/fmt/fmt_test.go)。

## 性能

## 从 C 的改变
